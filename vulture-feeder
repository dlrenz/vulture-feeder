#!/usr/bin/env python3
# A script to recklessly wipe out (supposedly) dead code identified by Vulture.
# Warning, this may destroy your software if vulture is incorrect.
#
# VULTURE INSTALLATION: https://pypi.org/project/vulture/
#          pip install vulture
#
# USAGE:
#          Check what vulture finds:
#          vulture mydir
#
#          If you agree to DESTROY the code vulture found:
#          vulture mydir | vulture-feeder
#
# STATUS:  Pre-Alpha!  Only functions are deleted currently.
#          You may need to do some manual editing to fix things that break.
# BUGS:    Functions with blank lines.
#          See: https://github.com/jonathancross/segwit-p2sh/commit/e1feee4e
#
# AUTHOR:  Jonathan Cross 0xC0C076132FFA7695 (jonathancross.com)
# LICENSE: WTFPL
#          https://github.com/jonathancross/vulture-feeder/blob/master/LICENSE
################################################################################

import sys
import re
import fileinput

# Parses output from the vulture command being piped into this script.
def parse_vulture(line):
    FILENAME_LINE = 0
    TYPE = 2
    FUNC_NAME = 3
    if line:
        line_split = line.split()
        if line_split[TYPE] == 'function':
            m = re.search("'(.+)'", line_split[FUNC_NAME])
            pieces = re.search("(.+):([0-9]+)", line_split[FILENAME_LINE])
            return {
                'func_name': m.group(1),
                'file_name': pieces.group(1),
                'line_no': int(pieces.group(2))}

# Outer loop handling one or more files to be cleaned up.
def cleanup_files(vulture_items):
    for file_name, locations in vulture_items.items():
      cleanup_file(file_name, locations)

# Cleans up zero or more dirty code chunks (locations) in a single file.
def cleanup_file(file_name, locations):
    func_indent_len = 0
    func_state = 'not_in_func' # TODO: Make constants?
    func_state_type = ''
    print('File: ' + file_name)
    dirty_file_contents = get_file_contents(file_name)
    clean_file_contents = []
    for i, line in enumerate(dirty_file_contents):
        cur_line_no = i + 1
        line_unindent = line.strip()
        line_indent_len = len(line) - len(line_unindent)
        if func_state == 'not_in_func':
            # Check all code locations to see if they match this line
            # TODO: Optimize - we only need to check the first location (locations[0]) (then delete it) because they are in order.
            for loc in locations:
                # If current location matches the start of a function to remove...
                if cur_line_no == loc['line_no']:
                    # TODO: Remove this loc to speed up future searches
                    func_indent_len = line_indent_len
                    # First line of a function that will be removed.
                    # Now need to find if it is a func def, or just decoration:
                    func_state = 'in_func'
                    if line_unindent.startswith('def '):
                        func_state_type = 'def_line'
                    else:
                        func_state_type = 'decorator_line'
                    print('  ' + str(loc['line_no']) + '. func_state: ' + func_state + ', func_state_type: ' + func_state_type + ', indent=' + str(func_indent_len) + ' ' + loc['func_name'] + ' = ' + line_unindent)
        elif func_state_type == 'decorator_line':
            if line_unindent.startswith('def '):
                func_state_type = 'def_line'
        elif func_state_type == 'def_line':
            is_indented = line_indent_len > func_indent_len
            if is_indented:
                func_state_type = 'def_body'
        elif func_state_type == 'def_body':
            is_indented = line_indent_len > func_indent_len
            if not is_indented:
                func_state_type = 'def_end'
                func_state = 'not_in_func'
        # If not in a function being deleted...
        if func_state == 'not_in_func':
            clean_file_contents.append(line)
        else:
            # DEBUG:
            print('      X ' + line_unindent)
    clean_file = open(file_name + '.new', 'w+')
    clean_file.writelines(clean_file_contents)
    clean_file.close()

# Loads and returns the contents of a file.
def get_file_contents(file_name):
    dirty_file = open(file_name, 'r')
    dirty_file_contents = dirty_file.readlines()
    dirty_file.close()
    return dirty_file_contents

# Read lines from STDIN indicating what should be cleaned up.
def read_vulture_data():
    # List of items (file name & line number) considered unnecessary.
    vulture_items = {}
    for line in sys.stdin.read().split('\n'):
        cleanup_item = parse_vulture(line)
        if cleanup_item:
            fn = cleanup_item['file_name']
            del cleanup_item['file_name']
            if not fn in vulture_items:
                vulture_items[fn] = []
            vulture_items[fn].append(cleanup_item)
    return vulture_items

# Begin cleanup process:
cleanup_files(read_vulture_data())

