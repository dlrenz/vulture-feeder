#!/usr/bin/env python3
# A script to recklessly wipe out (supposedly) dead code identified by Vulture.
# Warning, this may destroy your software if vulture is incorrect.
#
# VULTURE INSTALLATION: https://pypi.org/project/vulture/
#          pip install vulture
#
# USAGE:
#          Check what vulture finds:
#          vulture mydir
#
#          If you agree to wipe out the code vulture found:
#          vulture mydir | vulture-feeder
#
#          Each modified file will be written as mydir/FILENAME.new so as not to damage the original.
#          Eventually this will change to overwrite the original files.
#
# TESTING: cd test
#          ./_run_tests.sh
#
# STATUS:  Pre-Alpha!  Only functions are deleted currently.
#          You may need to do some manual editing to fix things that break.
#
# BUGS:    • Comments are not properly handled yet and can break the script.
#          • Nested functions not handled.  Would need to count indentation, etc.
#
# AUTHOR:  Jonathan Cross 0xC0C076132FFA7695 (jonathancross.com)
# LICENSE: WTFPL
#          https://github.com/jonathancross/vulture-feeder/blob/master/LICENSE
################################################################################

import sys
import re
import fileinput

def parse_vulture(line):
    """Parses output from the vulture command being piped into this script."""
    FILENAME_LINE = 0
    TYPE = 2
    FUNC_NAME = 3
    if line:
        line_split = line.split()
        if line_split[TYPE] == 'function':
            m = re.search("'(.+)'", line_split[FUNC_NAME])
            pieces = re.search("(.+):([0-9]+)", line_split[FILENAME_LINE])
            return {
                'func_name': m.group(1),
                'file_name': pieces.group(1),
                'line_no': int(pieces.group(2))}

def cleanup_files(vulture_items):
    """Outer loop handling one or more files to be cleaned up."""
    for file_name, locations in vulture_items.items():
      cleanup_file(file_name, locations)

def cleanup_file(file_name, locations):
    """Cleans up zero or more dirty code chunks (locations) in a single file."""
    print('File: ' + file_name)
    dirty_file_contents = get_file_contents(file_name)
    clean_file_contents = get_clean_file_contents(dirty_file_contents, locations)
    clean_file = open(file_name + '.new', 'w+')
    clean_file.writelines(clean_file_contents)
    clean_file.close()

def get_clean_file_contents(dirty_file_contents, locations):
    """Loops through a lines to determine if each should be preserved or discarded."""
    clean_file_contents = []
    state =  {
        'func_indent_len': 0,
        'in_func': False,
        'func_position': '',
        'is_clean': None
    }
    for i, line in enumerate(dirty_file_contents):
        state = get_line_parsing_state(i, line, locations, state)
        if state['is_clean']:
            clean_file_contents.append(line)
    return clean_file_contents

def get_line_parsing_state(i, line, locations, state):
    """Determines if a particular line should be preserved or discarded."""
    cur_line_no = i + 1
    line_unindent = line.lstrip()
    line_indent_len = len(line) - len(line_unindent) # Sometimes == 0 for blank lines!
    # Handle blank line found on prev round.  Is this the end of the func?
    if state['func_position'] == 'def_body_blank_possible_end':
        # Not sure if this is enough.  Can next function be indented more than prev?
        is_indented = line_indent_len > state['func_indent_len']
        if is_indented or line_unindent == '':
            state['func_position'] = 'def_body'
            # DEBUG:
            print("   ---> Prev blank was NOT the end of func.  Now line is '" + line_unindent.rstrip() + "'")
        else:
            state['func_position'] = 'def_end'
            state['in_func'] = False
            state['func_indent_len'] = 0
            # DEBUG:
            print("   ---> Prev blank was the END of func.  Now line is '" + line_unindent.rstrip() + "'")

    # Check if we still have any functions to remove:
    if len(locations):
        # Check if line matches the start of a function to remove:
        if cur_line_no == locations[0]['line_no']:
            state['func_indent_len'] = line_indent_len
            # First line of a function that will be removed.
            # Now need to find if it is a func def, or just decoration:
            state['in_func'] = True
            if line_unindent.startswith('def '):
                state['func_position'] = 'def_line'
            else:
                state['func_position'] = 'decorator_line'
            print('  ' + str(locations[0]['line_no']) + '. in_func: ' + str(state['in_func']) + ', func_position: ' + state['func_position'] + ', indent=' + str(state['func_indent_len']) + ' ' + locations[0]['func_name'] + ' = ' + line_unindent.rstrip())
            # Remove this code deletion location as it is now taken care of.
            del locations[0]

    # If previous round, the line was an @ decorator before the actual def:
    if state['func_position'] == 'decorator_line':
        if line_unindent.startswith('def '):
            state['func_position'] = 'def_line'
    # If previous round, the def was found, then we now enter the body of the func.
    # TODO: Can we combine 'def_line' and 'def_body' ?
    elif state['func_position'] == 'def_line':
        # Comment line:
        if line_unindent.startswith('#'):
            # DEBUG:
            print(' COMMENT: ' + line.rstrip())
        is_indented = line_indent_len > state['func_indent_len']
        if is_indented:
            state['func_position'] = 'def_body'
    elif state['func_position'] == 'def_body':
        # blank line:
        if line_unindent == '':
            state['func_position'] = 'def_body_blank_possible_end'
        # Comment line:
        elif line_unindent.startswith('#'):
            # DEBUG:
            print(' COMMENT: ' + line.rstrip())
        else:
            is_indented = line_indent_len > state['func_indent_len']
            if not is_indented:
                state['func_position'] = 'def_end'
                state['in_func'] = False
                state['func_indent_len'] = 0
    # If not in a function being deleted...
    if not state['in_func']:
        state['is_clean'] = True
    elif line_unindent == '':
        state['is_clean'] = False
        # DEBUG:
        print(' BLANK ################################################ ')
    else:
        state['is_clean'] = False
        # DEBUG:
        print('      X ' + line_unindent.rstrip())
    return state

def get_file_contents(file_name):
    """Loads and returns the contents of a file."""
    dirty_file = open(file_name, 'r')
    dirty_file_contents = dirty_file.readlines()
    dirty_file.close()
    return dirty_file_contents

def read_vulture_data():
    """Read lines from STDIN indicating what should be cleaned up."""
    # List of items (file name & line number) considered unnecessary.
    vulture_items = {}
    for line in sys.stdin.read().split('\n'):
        cleanup_item = parse_vulture(line)
        if cleanup_item:
            fn = cleanup_item['file_name']
            del cleanup_item['file_name']
            if not fn in vulture_items:
                vulture_items[fn] = []
            vulture_items[fn].append(cleanup_item)
    return vulture_items

if __name__ == "__main__":
    """Begin cleanup process"""
    cleanup_files(read_vulture_data())
